# Document Template Customizer

This tool lets you produce *personalized document templates* from a larger base template repository, such as https://github.com/bflorat/architecture-document-template[this one].

While I‚Äôve received good feedback on my previous document templates, a recurring criticism was that the *templates were too large*, leaving many sections unused. With DTC, you can *prepare smaller, tailored templates* filtered from a larger one.

Any template following a simple metamodel is supported, not only my own templates.

## Common use cases

. An expert (typically an *Enterprise Architect*) selects or writes a base template. This base template is usually organization-wide.
. Another expert (typically a *Solution Architect*) creates a customized, curated template for one or several projects. This includes both a *full template with explanations* and *blank documents* to be filled.
. The project team then fills the *blank documents*, guided by the explanations in the customized template.

## Prerequisites for a Base Template

* The template must be written in **AsciiDoc (Asciidoctor flavor)** ‚Äî with sections starting with `#` characters, not `=`.
* A **`README.adoc`** file must be present at the root of the base template URL, providing an introduction.
* A **`base-template-metadata.yaml`** file must be present at the root of the base template URL. A sample is provided below. The `labels:` section in this file is ignored ‚Äî labels are automatically discovered from the parts.
* All part files must be located in the same directory than the `README.adoc` file.

.Sample `base-template-metadata.yaml` :

```
author: ACME
license: CC BY-SA 4.0
parts:
  - name: Application
    file: view-application.adoc
  - name: Development
    file: view-development.adoc
  - name: infrastructure
    file: view-infrastructure.adoc  
labels:
  - detail_level: 
      - abstract      # conceptual, principles, big picture
      - overview      # broad but slightly more concrete
      - detailed      # technical specifics, diagrams, modules
      - in-depth      # exhaustive detail, e.g., data models, algorithms
  - name: persistence
  - name: green-IT
```

* Every section of each part file of the base template should be annotated with a metadata line directly above the section title (no blank line), using an AsciiDoc comment:
  ** `//üè∑{"id": "74c82505-5f47-4342-8f1b-f6951d603062", "labels": ["level::basic", "project_size::*", "detail_level::abstract", "context"]}`
  ** Level‚Äë1 sections (single `#`) are always kept and should not be annotated.
  ** Labels are automatically discovered from `//üè∑{...}` markers in parts; you don‚Äôt need to list them in `base-template-metadata.yaml`.
  ** Labels can be a simple flag (e.g., `performance`).
  ** Multi‚Äëvalued labels use the `name::value` form (e.g., `project_size::large`, `project_size::medium`, `project_size::small`). Values are discovered from usage across parts; no YAML declaration is required.
  ** You can use the `*` wildcard in multi‚Äëvalued labels to mean ‚Äúany‚Äù. For instance, to always keep a section regardless of project size, use `project_size::*`.
  ** See many examples in https://github.com/bflorat/architecture-document-template[this base template].

## Matching rules

- If all or no labels are selected, the resulting template is the full base template.
- Level‚Äë1 sections (single `#`) are always kept.
- Labels use AND semantics: a section is kept only if all its labels are satisfied by the selection.
- If a parent section doesn‚Äôt match, all its subsections are dropped recursively.
- If a parent section matches, each subsection is evaluated and kept only if it matches.
- If the base template uses a wildcard multi‚Äëvalue label like `project_size::*`, it matches any selected label in the same namespace (e.g., `project_size::small`, `project_size::large`).

## Links 

- Use the `link_to` section metadata to automatically add a `TIP: See also <link>` entry in the generated templates and blank templates.

Sample: 

//üè∑{"id": "6ff8aacb-5020-4ade-a10d-3dce3898276b", "labels": [...],"link_to": ["c8e58371-6bea-48e2-ab0e-989fec63e0ee","53b2f98c-11d9-4aa0-b762-b8f31db0c30f"]}

- You can add links to another parts of the template (others documents). An asciidoc `xref` cross document would be generated.


## CLI usage

Build the CLI once, then generate a filtered archive:

```
npm run cli -- --base-url https://raw.githubusercontent.com/bflorat/architecture-document-template/refs/heads/feat/add-medadata  --include level::basic,persistence 
```

Options:

* `--base-url` (`-b`) ‚Äì required. The template root exposing `base-template-metadata.yaml`.
* `--include` (`-i`) ‚Äì comma-separated labels to keep (matching sections stay, others are pruned). Unknown labels abort the run.
* `--no-anchors` ‚Äì disable inserting Asciidoctor block IDs (`[#id]`) in both the resulting template and blank template.
* `--output` (`-o`) ‚Äì optional zip destination relative to the current directory (defaults to `custom-template.zip`).
* `--output-file` ‚Äì optional absolute or relative output path.

The generated archive contains two folders:

* `template/` keeps the filtered parts with their metadata marker lines intact.
* `blank-template/` contains the same parts reduced to section titles and AsciiDoc attributes (body text removed).

If no `--include` labels are provided, the resulting template contains every section of the base template. The base template **must** expose a `README.adoc` (case‚Äëinsensitive) alongside `base-template-metadata.yaml`.

In the web UI, you can toggle anchors via the "Include anchors [#id] in outputs" option.


## Tips
* The generated zip contains a `customization-context.yaml` file with the generation date, base template URL, and selected labels.
